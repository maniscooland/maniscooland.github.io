<!DOCTYPE html>
<html>
<head>
    <title>2D Battle Game</title>
    <style>
        canvas {
            border: 1px solid black;
            background: #eee;
            cursor: crosshair;
        }
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Game constants
        const BULLET_SPEED = 10;
        const AI_COUNT = 5;
        const VEHICLE_COUNT = 3;

        class Bullet {
            constructor(x, y, angle, shooter) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.shooter = shooter;
                this.speed = BULLET_SPEED;
                this.active = true;
            }

            update() {
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
                ctx.fillStyle = '#e74c3c';
                ctx.fill();
            }
        }

        class Player {
            constructor(x, y, isAI = false) {
                this.x = x;
                this.y = y;
                this.speed = 5;
                this.angle = 0;
                this.health = 100;
                this.isAI = isAI;
                this.inVehicle = null;
                this.shootCooldown = 0;
                this.target = null;
                this.aiState = 'roaming';
                this.targetX = null;
                this.targetY = null;
            }

            draw() {
                if (this.health <= 0 || this.inVehicle) return;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                // Health bar
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(-25, -40, (this.health/100) * 50, 5);
                
                // Body
                ctx.beginPath();
                ctx.arc(0, 0, 20, 0, Math.PI * 2);
                ctx.fillStyle = this.isAI ? '#e74c3c' : '#3498db';
                ctx.fill();
                
                // Hands
                ctx.beginPath();
                ctx.arc(-25, -25, 8, 0, Math.PI * 2);
                ctx.arc(25, -25, 8, 0, Math.PI * 2);
                ctx.fillStyle = '#e74c3c';
                ctx.fill();
                
                ctx.restore();
            }

            shoot() {
                if (this.shootCooldown <= 0 && !this.inVehicle) {
                    bullets.push(new Bullet(this.x, this.y, this.angle, this));
                    this.shootCooldown = 20;
                }
            }

            update() {
                if (this.health <= 0) return;
                
                if (this.shootCooldown > 0) this.shootCooldown--;

                if (this.isAI) {
                    this.updateAI();
                } else if (!this.inVehicle) {
                    if (keys['w']) this.y -= this.speed;
                    if (keys['s']) this.y += this.speed;
                    if (keys['a']) this.x -= this.speed;
                    if (keys['d']) this.x += this.speed;
                    
                    this.angle = Math.atan2(mouseY - this.y, mouseX - this.x);
                }
            }

            updateAI() {
                // Random behavior switching
                if (Math.random() < 0.005) {
                    this.aiState = Math.random() < 0.5 ? 'roaming' : 'hunting';
                }

                // Try to enter vehicle
                if (!this.inVehicle && Math.random() < 0.01) {
                    const nearbyVehicle = vehicles.find(v => 
                        Math.hypot(v.x - this.x, v.y - this.y) < 100 &&
                        !v.driver && v.health > 0
                    );
                    if (nearbyVehicle) {
                        nearbyVehicle.driver = this;
                        this.inVehicle = nearbyVehicle;
                    }
                }

                // Exit vehicle randomly
                if (this.inVehicle && Math.random() < 0.005) {
                    this.inVehicle.driver = null;
                    this.x = this.inVehicle.x + 50;
                    this.y = this.inVehicle.y;
                    this.inVehicle = null;
                }

                if (this.inVehicle) {
                    // Vehicle driving behavior
                    if (Math.random() < 0.1) this.inVehicle.speed = 5;
                    if (Math.random() < 0.05) this.inVehicle.angle += (Math.random() - 0.5) * 0.2;
                } else {
                    // On-foot behavior
                    if (this.aiState === 'roaming') {
                        // Random movement
                        if (Math.random() < 0.05) {
                            this.targetX = Math.random() * canvas.width;
                            this.targetY = Math.random() * canvas.height;
                        }
                        if (this.targetX) {
                            const dx = this.targetX - this.x;
                            const dy = this.targetY - this.y;
                            this.angle = Math.atan2(dy, dx);
                            this.x += Math.cos(this.angle) * this.speed * 0.5;
                            this.y += Math.sin(this.angle) * this.speed * 0.5;
                        }
                    } else {
                        // Hunting behavior
                        if (!this.target || this.target.health <= 0) {
                            this.findNewTarget();
                        }
                        if (this.target) {
                            const dx = this.target.x - this.x;
                            const dy = this.target.y - this.y;
                            this.angle = Math.atan2(dy, dx);
                            this.x += Math.cos(this.angle) * this.speed * 0.5;
                            this.y += Math.sin(this.angle) * this.speed * 0.5;
                            if (Math.random() < 0.05) this.shoot();
                        }
                    }
                }
            }

            findNewTarget() {
                const possibleTargets = [...players, mainPlayer].filter(p => 
                    p !== this && p.health > 0
                );
                if (possibleTargets.length > 0) {
                    this.target = possibleTargets[Math.floor(Math.random() * possibleTargets.length)];
                }
            }
        }

        class Vehicle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 120;
                this.height = 80;
                this.angle = 0;
                this.speed = 0;
                this.driver = null;
                this.health = 200;
            }

            draw() {
                if (this.health <= 0) return;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                // Health bar
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(-this.width/2, -this.height/2 - 20, (this.health/200) * this.width, 5);
                
                // Car body
                ctx.fillStyle = '#95a5a6';
                ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                
                // Wheels
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(-this.width/2, -this.height/2, 20, 20);
                ctx.fillRect(this.width/2 - 20, -this.height/2, 20, 20);
                ctx.fillRect(-this.width/2, this.height/2 - 20, 20, 20);
                ctx.fillRect(this.width/2 - 20, this.height/2 - 20, 20, 20);
                
                // Seats
                ctx.fillStyle = '#34495e';
                ctx.fillRect(-20, -10, 40, 20);
                
                ctx.restore();
            }

            update() {
                if (this.health <= 0) return;
                
                if (this.driver) {
                    if (this.driver.isAI) {
                        // AI driving is handled in updateAI()
                    } else {
                        if (keys['w']) this.speed = 5;
                        else if (keys['s']) this.speed = -3;
                        else this.speed *= 0.95;

                        if (keys['a']) this.angle -= 0.05;
                        if (keys['d']) this.angle += 0.05;
                    }

                    this.driver.x = this.x;
                    this.driver.y = this.y;
                }

                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
            }
        }

        // Game variables
        const mainPlayer = new Player(canvas.width/2, canvas.height/2);
        const players = [];
        const vehicles = [];
        const bullets = [];
        let mouseX = 0;
        let mouseY = 0;
        const keys = {};

        // Create AI players
        for (let i = 0; i < AI_COUNT; i++) {
            players.push(new Player(
                Math.random() * canvas.width,
                Math.random() * canvas.height,
                true
            ));
        }

        // Create vehicles
        for (let i = 0; i < VEHICLE_COUNT; i++) {
            vehicles.push(new Vehicle(
                Math.random() * canvas.width,
                Math.random() * canvas.height
            ));
        }

        // Event listeners
        window.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === 'e') {
                if (!mainPlayer.inVehicle) {
                    const nearbyVehicle = vehicles.find(v => 
                        Math.hypot(v.x - mainPlayer.x, v.y - mainPlayer.y) < 100 &&
                        !v.driver && v.health > 0
                    );
                    if (nearbyVehicle) {
                        nearbyVehicle.driver = mainPlayer;
                        mainPlayer.inVehicle = nearbyVehicle;
                    }
                } else {
                    mainPlayer.inVehicle.driver = null;
                    mainPlayer.x = mainPlayer.inVehicle.x + 50;
                    mainPlayer.y = mainPlayer.inVehicle.y;
                    mainPlayer.inVehicle = null;
                }
            }
        });

        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
        window.addEventListener('mousemove', e => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        
        canvas.addEventListener('mousedown', () => {
            mainPlayer.shoot();
        });

        function checkCollisions() {
            bullets.forEach(bullet => {
                [...players, mainPlayer].forEach(player => {
                    if (player !== bullet.shooter && player.health > 0 && !player.inVehicle) {
                        if (Math.hypot(bullet.x - player.x, bullet.y - player.y) < 20) {
                            player.health -= 10;
                            bullet.active = false;
                        }
                    }
                });

                vehicles.forEach(vehicle => {
                    if (vehicle.health > 0 &&
                        bullet.x > vehicle.x - vehicle.width/2 &&
                        bullet.x < vehicle.x + vehicle.width/2 &&
                        bullet.y > vehicle.y - vehicle.height/2 &&
                        bullet.y < vehicle.y + vehicle.height/2) {
                        vehicle.health -= 5;
                        bullet.active = false;
                    }
                });
            });
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            vehicles.forEach(v => {
                v.update();
                v.draw();
            });

            mainPlayer.update();
            mainPlayer.draw();
            players.forEach(p => {
                p.update();
                p.draw();
            });

            bullets.forEach(b => {
                b.update();
                b.draw();
            });

            bullets.forEach((bullet, index) => {
                if (!bullet.active || 
                    bullet.x < 0 || bullet.x > canvas.width ||
                    bullet.y < 0 || bullet.y > canvas.height) {
                    bullets.splice(index, 1);
                }
            });

            checkCollisions();
            
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>
