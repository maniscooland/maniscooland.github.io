<!DOCTYPE html>
<html>
<head>
    <title>Massive World Battle</title>
    <style>
        * { margin: 0; padding: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const glove1 = new Image();
        const glove2 = new Image();
        glove1.src = 'ga1.png';
        glove2.src = 'ga2.png';

        Promise.all([
            new Promise(resolve => glove1.onload = resolve),
            new Promise(resolve => glove2.onload = resolve)
        ]).then(() => {
            gameLoop();
        });

        const WORLD_WIDTH = 90000;
        const WORLD_HEIGHT = 90000;
        const SCENE_SIZE = WORLD_WIDTH / 2;

        const SCENES = {
            forest: { background: '#2D5A27', pathColor: '#8B4513', pathBorder: '#654321' },
            desert: { background: '#DAA520', pathColor: '#D2691E', pathBorder: '#8B4513' },
            mountain: { background: '#4A5D23', pathColor: '#8B4513', pathBorder: '#654321' },
            lake: { background: '#1E4D2B', pathColor: '#8B4513', pathBorder: '#654321' }
        };

        const paths = [
            {x: 0, y: WORLD_HEIGHT/2 - 1000, width: WORLD_WIDTH, height: 2000},
            {x: WORLD_WIDTH/2 - 1000, y: 0, width: 2000, height: WORLD_HEIGHT},
            {x: WORLD_WIDTH/4, y: WORLD_HEIGHT/4, width: 2000, height: WORLD_HEIGHT/2, rotation: Math.PI/4},
            {x: WORLD_WIDTH*3/4, y: WORLD_HEIGHT/4, width: 2000, height: WORLD_HEIGHT/2, rotation: -Math.PI/4}
        ];

        const camera = {
            x: 0,
            y: 0,
            scale: 0.25,
            follow(target) {
                const targetX = -target.x * this.scale + canvas.width/2;
                const targetY = -target.y * this.scale + canvas.height/2;
                this.x += (targetX - this.x) * 0.1;
                this.y += (targetY - this.y) * 0.1;
            }
        };

        class Character {
            constructor(x, y, team = 'neutral') {
                this.x = x;
                this.y = y;
                this.rotation = 0;
                this.speed = 15;
                this.health = 100;
                this.team = team;
                this.vehicle = null;
                this.target = null;
                this.color = this.getTeamColor();
                this.isAI = true;
            }

            getTeamColor() {
                return { 'red': '#ff4444', 'blue': '#4444ff', 'green': '#44ff44', 'player': '#ffff44' }[this.team] || '#aaaaaa';
            }

            draw() {
                if (this.vehicle) return;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(-40, -60, 80, 10);
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(-40, -60, 80 * (this.health/100), 10);
                ctx.beginPath();
                ctx.arc(0, 0, 40, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.drawImage(glove1, 30, -20, 40, 40);
                ctx.drawImage(glove2, 30, 0, 40, 40);
                ctx.restore();
            }

            update() {
                if (this.health <= 0) return;
                if (this.isAI) {
                    if (!this.vehicle) {
                        if (!this.target || this.reachedTarget()) {
                            this.target = { x: Math.random() * WORLD_WIDTH, y: Math.random() * WORLD_HEIGHT };
                        }
                        const dx = this.target.x - this.x;
                        const dy = this.target.y - this.y;
                        this.rotation = Math.atan2(dy, dx);
                        this.x += Math.cos(this.rotation) * this.speed;
                        this.y += Math.sin(this.rotation) * this.speed;
                        if (Math.random() < 0.01) {
                            vehicles.forEach(v => {
                                if (!v.driver && Math.hypot(v.x - this.x, v.y - this.y) < 100) {
                                    this.vehicle = v;
                                    v.driver = this;
                                }
                            });
                        }
                    } else {
                        if (Math.random() < 0.005) {
                            this.vehicle.driver = null;
                            this.vehicle = null;
                        }
                    }
                }
                this.x = Math.max(0, Math.min(WORLD_WIDTH, this.x));
                this.y = Math.max(0, Math.min(WORLD_HEIGHT, this.y));
            }

            reachedTarget() {
                return Math.hypot(this.target.x - this.x, this.target.y - this.y) < 100;
            }
        }

        class Vehicle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 160;
                this.height = 80;
                this.wheelBase = 80;
                this.wheelAngle = 0;
                this.maxWheelAngle = Math.PI/4;
                this.speed = 0;
                this.maxSpeed = 30;
                this.acceleration = 0.5;
                this.deceleration = 0.3;
                this.angle = 0;
                this.driver = null;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.fillStyle = '#888888';
                ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                ctx.restore();
            }

            update() {
                if (this.driver) {
                    if (this.speed < this.maxSpeed) {
                        this.speed += this.acceleration;
                    }
                    this.angle += this.wheelAngle * this.speed / this.wheelBase;
                } else {
                    if (this.speed > 0) {
                        this.speed -= this.deceleration;
                    } else {
                        this.speed = 0;
                    }
                }
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                this.x = Math.max(0, Math.min(WORLD_WIDTH, this.x));
                this.y = Math.max(0, Math.min(WORLD_HEIGHT, this.y));
                if (this.driver) {
                    this.driver.x = this.x;
                    this.driver.y = this.y;
                }
            }
        }

        const player = new Character(WORLD_WIDTH / 2, WORLD_HEIGHT / 2, 'player');
        player.isAI = false;

        const characters = [player];
        const vehicles = [];

        for (let i = 0; i < 100; i++) {
            characters.push(new Character(Math.random() * WORLD_WIDTH, Math.random() * WORLD_HEIGHT, ['red', 'blue', 'green'][Math.floor(Math.random() * 3)]));
        }

        for (let i = 0; i < 50; i++) {
            vehicles.push(new Vehicle(Math.random() * WORLD_WIDTH, Math.random() * WORLD_HEIGHT));
        }

        function drawWorld() {
            ctx.save();
            ctx.translate(camera.x, camera.y);
            ctx.scale(camera.scale, camera.scale);

            const scenes = [
                { scene: SCENES.forest, x: 0, y: 0 },
                { scene: SCENES.desert, x: SCENE_SIZE, y: 0 },
                { scene: SCENES.mountain, x: 0, y: SCENE_SIZE },
                { scene: SCENES.lake, x: SCENE_SIZE, y: SCENE_SIZE }
            ];

            scenes.forEach(({ scene, x, y }) => {
                ctx.fillStyle = scene.background;
                ctx.fillRect(x, y, SCENE_SIZE, SCENE_SIZE);
            });

            paths.forEach(path => {
                ctx.save();
                ctx.translate(path.x + path.width / 2, path.y + path.height / 2);
                if (path.rotation) ctx.rotate(path.rotation);
                ctx.fillStyle = SCENES.forest.pathColor;
                ctx.fillRect(-path.width / 2, -path.height / 2, path.width, path.height);
                ctx.strokeStyle = SCENES.forest.pathBorder;
                ctx.lineWidth = 20;
                ctx.strokeRect(-path.width / 2, -path.height / 2, path.width, path.height);
                ctx.restore();
            });

            vehicles.forEach(v => v.draw());
            characters.forEach(c => c.draw());

            ctx.restore();
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            characters.forEach(c => c.update());
            vehicles.forEach(v => v.update());

            camera.follow(player);
            drawWorld();

            requestAnimationFrame(gameLoop);
        }

        window.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'w': player.y -= player.speed; break;
                case 's': player.y += player.speed; break;
                case 'a': player.x -= player.speed; break;
                case 'd': player.x += player.speed; break;
                case 'e':
                    if (!player.vehicle) {
                        const nearbyVehicle = vehicles.find(v => !v.driver && Math.hypot(v.x - player.x, v.y - player.y) < 100);
                        if (nearbyVehicle) {
                            player.vehicle = nearbyVehicle;
                            nearbyVehicle.driver = player;
                        }
                    } else {
                        player.vehicle.driver = null;
                        player.vehicle = null;
                    }
                    break;
            }
        });

        window.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = (e.clientX - rect.left) / camera.scale - camera.x / camera.scale;
            const mouseY = (e.clientY - rect.top) / camera.scale - camera.y / camera.scale;
            player.rotation = Math.atan2(mouseY - player.y, mouseX - player.x);
        });
    </script>
</body>
</html>
